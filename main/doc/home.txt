import sys
import pyvista as pv
import numpy as np
# Import necessary PyQt5 modules
from PyQt5 import QtWidgets, QtCore, QtGui # Added QtGui for Font
from PyQt5.QtWidgets import QSplitter, QHeaderView, QAbstractItemView # Added QSplitter, etc.
from pyvistaqt import QtInteractor

##############################################################################
#                              User Inputs & Defect Info (Keep as is)
##############################################################################

# Conversion factor
m_to_in = 39.3701

# Coordinates of the reference spheres (yellow), in meters
reference_spheres = {
    "top_front":    (-14.5649, -3.372,    66.8014),
    "bottom_front": (-15.3724,  0.108056, 17.3466),
    "top_back":     ( 21.6716,  5.41146,  66.6593),
    "bottom_back":  ( 22.2777,  0.75596,  17.4064),
}

# Input from Outside
indexVal1_input = 0.16
indexVal2_input = 0.409
depthVal_input = 0.092

airfoil_id = "airfoil123"
defect_id = "defect45"
defect_title = "Blend Info" # Keep original title for potential use

blend_fillet_radius        = 0.000
blend_depth                = 0.095
blend_length               = 0.238
blend_flat_length          = 0.125
blend_proportional_factor = 2.000
blend_location             = -0.285
blend_node_component       = "LENODES"

# Distances along the topâ†’bottom front vector (meters)
index1Val = indexVal1_input*19.0809
index2Val = indexVal2_input*19.0809

# Horizontal depth in +X (meters)
depthVal = depthVal_input*19.0809

# STL file to visualize
stl_file = "turbine2.stl"

##############################################################################
#                           Position Calculations (Keep as is)
##############################################################################

datum_pos = np.array(reference_spheres["top_front"])
vec_down = np.array(reference_spheres["bottom_front"]) - datum_pos
unit_vec_down = vec_down / np.linalg.norm(vec_down)

pos_red1 = datum_pos + unit_vec_down * index1Val
pos_red2 = datum_pos + unit_vec_down * index2Val
mid_z = (pos_red1[2] + pos_red2[2]) / 2.0
pos_red3 = np.array([datum_pos[0] + depthVal, datum_pos[1], mid_z])

##############################################################################
#                         Distances & Line Positions (Keep as is)
##############################################################################

dist1 = np.linalg.norm(pos_red1 - datum_pos)
dist2 = np.linalg.norm(pos_red2 - datum_pos)

arrow_depth_start = np.array([datum_pos[0], datum_pos[1], mid_z])
arrow_depth_end   = np.array([datum_pos[0] + depthVal, datum_pos[1], mid_z])

offset_1 = np.array([-3.0, 0.0, 0.0])
offset_2 = np.array([-6.0, 0.0, 0.0])

line1_start = pos_red1 + offset_1
line1_end   = datum_pos + offset_1
line2_start = pos_red2 + offset_2
line2_end   = datum_pos + offset_2

##############################################################################
#                         Create PyVista Objects (Keep as is)
##############################################################################

mesh = pv.read(stl_file)

sphere1 = pv.Sphere(radius=0.6, center=pos_red1)
sphere2 = pv.Sphere(radius=0.6, center=pos_red2)
sphere3 = pv.Sphere(radius=0.6, center=pos_red3)

line_v1 = pv.Line(line1_start, line1_end)
line_v2 = pv.Line(line2_start, line2_end)
line_depth = pv.Line(arrow_depth_start, arrow_depth_end)

##############################################################################
#                         Labels Data Calculation (Keep as is)
##############################################################################

txt_pos_v1 = (line1_start + line1_end) / 2
txt_pos_v2 = (line2_start + line2_end) / 2
txt_pos_depth = (arrow_depth_start + arrow_depth_end) / 2

scale_factor = 19.0809
dist1_scaled = dist1 / scale_factor
dist2_scaled = dist2 / scale_factor
depth_scaled = depthVal / scale_factor

if dist1 < dist2:
    short_pos, short_val = txt_pos_v1, dist1_scaled
    far_pos, far_val     = txt_pos_v2, dist2_scaled
else:
    short_pos, short_val = txt_pos_v2, dist2_scaled
    far_pos, far_val     = txt_pos_v1, dist1_scaled

short_label = f"Shortest distance to datum = {short_val:.3f} in"
far_label = f"Farthest distance to datum = {far_val:.3f} in"
depth_label = f"Depth = {depth_scaled:.3f} in"

##############################################################################
#                                PyQt Main Window
##############################################################################

class MainWindow(QtWidgets.QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Airfoil Defect Visualization")
        self.setGeometry(100, 100, 1300, 850) # Adjusted default size

        # --- Main Widget ---
        main_widget = QtWidgets.QWidget()
        self.setCentralWidget(main_widget)
        # Use QHBoxLayout to contain the splitter
        main_layout = QtWidgets.QHBoxLayout(main_widget)

        # --- Create QSplitter ---
        self.splitter = QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(self.splitter) # Add splitter to main layout

        # --- Left Side: PyVista Plotter ---
        plotter_frame = QtWidgets.QFrame()
        plotter_frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        plotter_layout = QtWidgets.QVBoxLayout(plotter_frame)
        plotter_layout.setContentsMargins(0,0,0,0) # Remove margins around plotter

        # Create the QtInteractor
        self.plotter = QtInteractor(plotter_frame)
        plotter_layout.addWidget(self.plotter.interactor) # Add the interactor widget
        self.splitter.addWidget(plotter_frame) # Add plotter frame to splitter

        # --- Right Side: Controls and Table ---
        controls_frame = QtWidgets.QWidget()
        controls_layout = QtWidgets.QVBoxLayout(controls_frame)
        self.splitter.addWidget(controls_frame) # Add controls frame to splitter

        # --- View Buttons (Moved Up) ---
        view_buttons_group = QtWidgets.QGroupBox("Camera Views")
        view_buttons_layout = QtWidgets.QVBoxLayout(view_buttons_group)
        controls_layout.addWidget(view_buttons_group) # Add first

        btn_xy = QtWidgets.QPushButton("XY View")
        btn_yz = QtWidgets.QPushButton("YZ View")
        btn_xz = QtWidgets.QPushButton("XZ View")

        btn_xy.clicked.connect(self.set_xy_view)
        btn_yz.clicked.connect(self.set_yz_view)
        btn_xz.clicked.connect(self.set_xz_view)

        view_buttons_layout.addWidget(btn_xy)
        view_buttons_layout.addWidget(btn_yz)
        view_buttons_layout.addWidget(btn_xz)

        # --- Defect Info Table (Added After Buttons) ---
        # More aesthetic title using newlines or separate labels if preferred
        table_group_title = f"Airfoil: {airfoil_id}\nDefect: {defect_id}\nParameters: {defect_title}"
        table_group = QtWidgets.QGroupBox(table_group_title)
        table_layout = QtWidgets.QVBoxLayout(table_group)
        controls_layout.addWidget(table_group) # Add second

        self.table = QtWidgets.QTableWidget()
        table_layout.addWidget(self.table)

        self.setup_table()

        controls_layout.addStretch() # Push elements to the top

        # --- Configure Splitter ---
        self.splitter.setSizes([800, 300]) # Initial size distribution (adjust as needed)
        self.splitter.setStretchFactor(0, 1) # Allow plotter side (index 0) to expand more
        self.splitter.setStretchFactor(1, 0) # Control side (index 1) less expansion

        # --- Populate PyVista Plot ---
        self.setup_plot()

    def setup_plot(self):
        """Adds meshes, labels, and axes to the PyVista plotter."""
        self.plotter.add_mesh(mesh, color="lightgray", opacity=1.0)

        # Reference Spheres
        for label, center in reference_spheres.items():
            sphere = pv.Sphere(radius=0.3, center=center)
            self.plotter.add_mesh(sphere, color="yellow", opacity=1.0)
            self.plotter.add_point_labels(
                [center + np.array([0,0,0.5])],
                [label.replace("_", " ").title()],
                font_size=10, point_color="black", always_visible=True
            )

        # Defect Position Spheres
        self.plotter.add_mesh(sphere1, color="red")
        self.plotter.add_mesh(sphere2, color="red")
        self.plotter.add_mesh(sphere3, color="red")

        # Measurement Lines
        self.plotter.add_mesh(line_v1, color="blue", line_width=5)
        self.plotter.add_mesh(line_v2, color="green", line_width=5)
        self.plotter.add_mesh(line_depth, color="magenta", line_width=5)

        # Measurement Labels
        self.plotter.add_point_labels(
            [short_pos], [short_label], font_size=12, point_color="black",
            shape=None, always_visible=True
        )
        self.plotter.add_point_labels(
            [far_pos], [far_label], font_size=12, point_color="black",
            shape=None, always_visible=True
        )
        self.plotter.add_point_labels(
            [txt_pos_depth], [depth_label], font_size=12, point_color="black",
            shape=None, always_visible=True
        )

        # --- Add Coordinate Axes ---
        self.plotter.add_axes(interactive=True) # interactive=True lets you drag it

        # Initial camera position
        self.plotter.camera_position = 'iso'
        self.plotter.reset_camera()


    def setup_table(self):
        """Populates the QTableWidget with defect parameters, units, and styling."""

        # Parameters requiring units
        params_with_units = ["Fillet Radius", "Blend Depth", "Blend Length", "Flat Length"]

        # Updated parameter names and structure
        data = {
            "Fillet Radius": f"{blend_fillet_radius:.3f}",
            "Blend Depth": f"{blend_depth:.3f}",        # Renamed
            "Blend Length": f"{blend_length:.3f}",       # Renamed
            "Flat Length": f"{blend_flat_length:.3f}",
            "Proportional Factor": f"{blend_proportional_factor:.3f}",
            "Location": f"{blend_location:.3f}",
            "Node Component": f"{blend_node_component}",
        }

        self.table.setColumnCount(2)
        self.table.setRowCount(len(data))
        self.table.setHorizontalHeaderLabels(["Blend Parameter", "Value"])

        # --- Style the Header ---
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        # Set bold font for header items
        font = header.font()
        font.setBold(True)
        header.setFont(font)
        # Optional: Basic background color for header
        header.setStyleSheet("QHeaderView::section { background-color: #E0E0E0; padding: 4px; border: 1px solid #C0C0C0; }")


        row = 0
        for key, value in data.items():
            param_item = QtWidgets.QTableWidgetItem(key)

            # Add units if the parameter name is in the list
            if key in params_with_units:
                value_text = f"{value} in"
            else:
                value_text = value
            value_item = QtWidgets.QTableWidgetItem(value_text)

            self.table.setItem(row, 0, param_item)
            self.table.setItem(row, 1, value_item)
            row += 1

        # Style the table
        self.table.verticalHeader().setVisible(False) # Hide row numbers
        self.table.resizeRowsToContents()
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers) # Make read-only
        self.table.setAlternatingRowColors(True) # Improve readability


    # --- Camera View Slot Methods (Keep as is, maybe adjust zoom/distance) ---
    def set_xy_view(self):
        # Adjust Z distance for desired zoom
        self.plotter.view_xy(negative=False) # Use convenience method
        # self.plotter.camera.position = (mesh.center[0], mesh.center[1], mesh.center[2] + 150)
        # self.plotter.camera.focal_point = mesh.center
        # self.plotter.camera.up = (0, 1, 0)
        self.plotter.reset_camera() # Reset camera often adjusts zoom nicely
        self.plotter.reset_camera_clipping_range()
        self.plotter.render()

    def set_yz_view(self):
        # Look from negative X towards positive X
        self.plotter.view_yz(negative=True) # Use convenience method
        # center_focus = mesh.center
        # distance = 100 # Adjust distance as needed
        # self.plotter.camera.position = (center_focus[0] - distance, center_focus[1], center_focus[2])
        # self.plotter.camera.focal_point = center_focus
        # self.plotter.camera.up = (0, 0, 1) # Z is up
        self.plotter.reset_camera()
        self.plotter.reset_camera_clipping_range()
        self.plotter.render()


    def set_xz_view(self):
        # Look from negative Y towards positive Y
        self.plotter.view_xz(negative=True) # Use convenience method
        # center_focus = mesh.center
        # distance = 100 # Adjust distance as needed
        # self.plotter.camera.position = (center_focus[0], center_focus[1] - distance, center_focus[2])
        # self.plotter.camera.focal_point = center_focus
        # self.plotter.camera.up = (0, 0, 1) # Z is up
        self.plotter.reset_camera()
        self.plotter.reset_camera_clipping_range()
        self.plotter.render()


##############################################################################
#                                Run Application
##############################################################################

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
