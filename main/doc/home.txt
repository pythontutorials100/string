#!/usr/bin/env python3
import csv
import re
import sys
import argparse

###############################################################################
# 1) Define prefixes
###############################################################################
PREFIXES = {
    '': 'http://api.stardog.com/',  # default namespace for your entities
    'owl': 'http://www.w3.org/2002/07/owl#',
    'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    'rdfs': 'http://www.w3.org/2000/01/rdf-schema#',
    'xsd': 'http://www.w3.org/2001/XMLSchema#'
}

###############################################################################
# 2) Utility: sanitize local names and format IRIs
###############################################################################
def sanitize_local_part(text: str) -> str:
    """
    Replaces any run of non-allowed characters with underscores
    to ensure a valid Turtle local name.
    Allowed: letters, digits, underscore, dash, dot.
    """
    # Replace sequences of invalid chars with '_'
    return re.sub(r'[^a-zA-Z0-9_\-\.]+', '_', text)

def format_uri(name: str) -> str:
    """
    Converts a raw string into a valid Turtle prefixed name or a full IRI.
    1) Strip whitespace.
    2) If there's a known prefix, keep it. Otherwise use the default ':' prefix.
    3) If prefix is unknown but there's a colon, treat the entire thing as a full IRI (<...>).
    4) Replace invalid characters with underscores in local names.
    """
    name = name.strip()
    if not name:
        return None

    if ':' in name:
        # Possibly a prefixed name or a full IRI
        possible_prefix, local_part = name.split(':', 1)
        possible_prefix = possible_prefix.strip()
        local_part = local_part.strip()

        if possible_prefix in PREFIXES:
            # recognized prefix => keep prefix: localPart
            local_part_sanitized = sanitize_local_part(local_part)
            return f'{possible_prefix}:{local_part_sanitized}'
        else:
            # not recognized => treat as a full IRI
            return f'<{name}>'
    else:
        # default prefix
        local_sanitized = sanitize_local_part(name)
        return f':{local_sanitized}'

###############################################################################
# 3) Map CSV predicates to known data properties (with optional datatypes)
#    You can expand as needed.
###############################################################################
LITERAL_PREDICATES = {
    'has decimal value': (':has_decimal_value', 'xsd:decimal'),
    'has text value': (':has_text_value', None),
    # Example expansions:
    # 'has integer value': (':has_integer_value', 'xsd:integer'),
    # 'has boolean value': (':has_boolean_value', 'xsd:boolean'),
}

###############################################################################
# Main conversion logic
###############################################################################
def convert_csv_to_ttl(input_csv: str, output_ttl: str):
    """
    Reads a CSV with columns:
      Subject, SubjectType, Predicate, Object, ObjectType
    and converts it to a Turtle (.ttl) file.
    """
    triples_data = []

    # 1) Read CSV rows
    with open(input_csv, 'r', newline='', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            s = row['Subject'].strip()
            stype = row['SubjectType'].strip()
            p = row['Predicate'].strip()
            o = row['Object'].strip()
            otype = row['ObjectType'].strip()
            triples_data.append((s, stype, p, o, otype))

    # 2) Prepare containers
    classes = set()               # track all class names
    subclass_triples = []         # rdfs:subClassOf lines
    triples_ttl = []              # other instance/data/object lines
    object_props_info = {}        # propertyURI -> { 'domain': set(), 'range': set() }

    # 3) Convert each row to TTL
    for subject, subject_type, predicate, obj, object_type in triples_data:
        s_uri = format_uri(subject)
        o_uri = format_uri(obj)
        p_lower = predicate.lower().strip()

        # (A) subClassOf
        if p_lower in ["subclass of", "rdfs:subclassof", "subclassof"]:
            if s_uri and o_uri:
                subclass_triples.append(f"{s_uri} rdfs:subClassOf {o_uri} .")
                # Mark them as classes
                classes.add(subject)
                classes.add(obj)
            else:
                print(f"[Warning] Incomplete 'subclass of' triple: {subject} -> {obj}")
            continue

        # (B) rdf:type
        if p_lower == "rdf:type":
            # subject a object
            if s_uri and o_uri:
                # If object is a Class, store it
                if object_type == "Class":
                    classes.add(obj)
                triples_ttl.append(f"{s_uri} a {o_uri} .")
            else:
                print(f"[Warning] Incomplete 'rdf:type' triple: {subject} -> {obj}")
            continue

        # (C) known literal predicates
        if predicate in LITERAL_PREDICATES:
            prop_uri, datatype = LITERAL_PREDICATES[predicate]
            if s_uri:
                if datatype:
                    # typed literal
                    triples_ttl.append(f'{s_uri} {prop_uri} "{obj}"^^{datatype} .')
                else:
                    # plain string
                    escaped = obj.replace('"', '\\"')
                    triples_ttl.append(f'{s_uri} {prop_uri} "{escaped}" .')
            else:
                print(f"[Warning] Missing subject for literal predicate '{predicate}' -> {obj}")
            continue

        # (D) If object is a literal but not in known predicates, treat the predicate as a data property
        if object_type.lower() == "literal":
            if s_uri:
                property_uri = f":{sanitize_local_part(predicate)}"
                escaped = obj.replace('"', '\\"')
                # default to string literal
                triples_ttl.append(f'{s_uri} {property_uri} "{escaped}" .')
            else:
                print(f"[Warning] Missing subject for literal predicate '{predicate}' -> {obj}")
            continue

        # (E) Otherwise treat as an object property
        if s_uri and o_uri:
            prop_uri = f":{sanitize_local_part(predicate)}"
            triples_ttl.append(f"{s_uri} {prop_uri} {o_uri} .")

            # domain/range if subject & object are classes
            if subject_type == "Class" and object_type == "Class":
                if prop_uri not in object_props_info:
                    object_props_info[prop_uri] = {'domain': set(), 'range': set()}
                object_props_info[prop_uri]['domain'].add(format_uri(subject))
                object_props_info[prop_uri]['range'].add(format_uri(obj))
        else:
            print(f"[Warning] Incomplete triple: {subject}, {predicate}, {obj}")

    # 4) Build up TTL text
    # 4a) Prefix lines
    ttl_prefixes = "\n".join([f"@prefix {k}: <{v}> ." for k, v in PREFIXES.items()])

    # 4b) Class declarations
    class_defs = []
    for c in classes:
        c_uri = format_uri(c)
        if c_uri:
            class_defs.append(f"{c_uri} rdf:type owl:Class .")
        else:
            print(f"[Warning] Could not format class '{c}'")

    # 4c) Object property declarations
    obj_prop_defs = []
    for prop_uri, info_dict in object_props_info.items():
        domains = info_dict['domain']
        ranges = info_dict['range']
        lines = [f"{prop_uri} rdf:type owl:ObjectProperty ."]
        if domains:
            for d in domains:
                lines.append(f"{prop_uri} rdfs:domain {d} .")
        if ranges:
            for r in ranges:
                lines.append(f"{prop_uri} rdfs:range {r} .")

        label_str = prop_uri.lstrip(":").replace("_", " ")
        lines.append(f'{prop_uri} rdfs:label "{label_str}" .')
        obj_prop_defs.append("\n".join(lines))

    # 4d) Subclass lines
    subclass_text = "\n".join(subclass_triples)

    # 4e) The main triple lines
    triple_text = "\n".join(triples_ttl)

    # 5) Final TTL content
    ttl_content = "\n\n".join([
        ttl_prefixes,
        "# ------------------ CLASSES ------------------",
        "\n".join(class_defs),
        "# ------------------ OBJECT PROPERTIES ------------------",
        "\n\n".join(obj_prop_defs),
        "# ------------------ SUBCLASS STATEMENTS ------------------",
        subclass_text,
        "# ------------------ OTHER TRIPLES ------------------",
        triple_text
    ])

    # 6) Write .ttl file
    with open(output_ttl, 'w', encoding='utf-8') as f:
        f.write(ttl_content)

    print(f"TTL file generated successfully: {output_ttl}")


###############################################################################
# Main entry point (CLI)
###############################################################################
def main():
    parser = argparse.ArgumentParser(
        description="Convert a CSV of Subject, SubjectType, Predicate, Object, ObjectType to Turtle ontology."
    )
    parser.add_argument('-i', '--input', type=str, default='output_extended_csv.csv',
                        help='Input CSV file (default: output_extended_csv.csv)')
    parser.add_argument('-o', '--output', type=str, default='output_defect_6extended.ttl',
                        help='Output TTL file (default: output_defect_6extended.ttl)')

    args = parser.parse_args()

    convert_csv_to_ttl(args.input, args.output)

if __name__ == '__main__':
    main()

