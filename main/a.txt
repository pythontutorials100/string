-Artificial Intelligence A Modern Approach 3'rd Edition by Russell & Norvig - Chapter 7 - 12 (Knowledge, Reasoning and Planning)
-Introduction to Logic 3'rd Edition, Genesereth & Kao
-Knowledge Representation and Reasoning by Brachman and Levesque

------------------

2. Using SHACL (Shapes Constraint Language)

Where SWRL derives new facts (like measuredFrom3(?d, ex:LeadingEdge)) at reasoning time, SHACL is typically used for validating data or enforcing constraints—though it can also do some rule-like “property assignment” via extensions (SHACL Rules or SHACL Advanced Features).
2.1 SHACL Validation Example

A SHACL shape can say:

    “For any Defect whose chordwiseDistToLeadingEdge < 0.080, must have measuredFrom3 = LeadingEdge.”

You’d create a shape roughly like:

ex:LeadingEdgeRuleShape
  rdf:type sh:NodeShape ;
  sh:targetClass ex:Defect ;
  # Condition: chordwiseDistToLeadingEdge < 0.08
  sh:message "If chordwise < 0.08 from leading edge, measure Index3 from leading edge." ;
  sh:condition ex:ChordwiseLessThanEdgeCondition ;  # a custom SHACL extension or function
  sh:property [
     sh:path ex:measuredFrom3 ;
     sh:hasValue ex:LeadingEdge ;  # requires that measuredFrom3 is LeadingEdge
  ] .

(Exact syntax depends on your SHACL engine, especially if you need numeric comparisons.)
If a data instance violates this shape, you get a validation error.
2.2 SHACL Rules

The SHACL Advanced Features (SHACL-AF) has a notion of “rules” that can create triples if a condition is met—similar to SWRL. For example:

ex:LeadingEdgeAssignRule a sh:NodeShape ;
    sh:targetClass ex:Defect ;
    sh:rule [
      rdf:type sh:TripleRule ;
      sh:condition [
         sh:path ex:chordwiseDistToLeadingEdge ;
         sh:datatype xsd:float ;
         # Pseudocode: if chordwiseDist < 0.08
         # Depending on your SHACL engine’s extension for numeric filters
      ] ;
      sh:subject sh:this ;
      sh:predicate ex:measuredFrom3 ;
      sh:object ex:LeadingEdge ;
    ] .

When run, the engine sees a Defect with chordwiseDistToLeadingEdge < 0.08 and automatically adds the triple (thatDefect measuredFrom3 LeadingEdge).
3. Storing / Organizing the Rules

In OWL you can create a “placeholder” class or individual, e.g. ex:DefectMeasurementRule, typed under cco:Algorithm or cco:ActionRequirement, and attach each SWRL or SHACL rule to it as an annotation. For example, in Protégé you can store your SWRL rules in the ontology’s “SWRL Tab” (they become part of the .owl file). Or you can keep them in a separate file and refer to them from an owl:AnnotationProperty. Common patterns:

    Inline: Keep the rules directly in the same .owl ontology (Protégé can store them that way).
    Separate: Put rules in a separate .swrlt or .shapes.ttl file, then import or reference them from your main ontology.

4. Putting It All Together

    Model your domain in OWL (classes for Defect, data properties for chordwise/spanning distances, etc.).
    Choose a rule approach:
        SWRL if you want to do forward-chaining or inference inside a typical OWL reasoner.
        SHACL if you want data validation or property assignment in a more constraint-based environment.
    Write the rules for each “if < 0.080 then measure from leading edge” scenario.
    Run your reasoner or SHACL engine:
        SWRL: The engine will infer new properties (like measuredFrom3(Defect_1, LeadingEdge)), or you can do queries.
        SHACL: The engine will validate or auto‐assign the property based on your shape definitions.
    Store or annotate those rules in your ontology so that the logic is documented and travels with the rest of your domain model.

This way, your final knowledge graph (in e.g. Stardog) can automatically interpret new defect data (like chordwise = 0.05, spanwise = 0.5) and conclude that Index 3 is from the leading edge and Index 1,2 are from the platform—all driven by the rules you’ve embedded alongside the OWL classes.
